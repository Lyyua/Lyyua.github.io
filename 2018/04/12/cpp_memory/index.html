<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="C++," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="先交代最基本的原则。">
<meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ 对象模型">
<meta property="og:url" content="http://lyyua.com/2018/04/12/cpp_memory/index.html">
<meta property="og:site_name" content="Back">
<meta property="og:description" content="先交代最基本的原则。">
<meta property="og:image" content="http://lyyua.com/2018/04/12/cpp_memory/struct1.png">
<meta property="og:image" content="http://lyyua.com/2018/04/12/cpp_memory/struct2.png">
<meta property="og:image" content="http://lyyua.com/2018/04/12/cpp_memory/cppstruct.jpg">
<meta property="og:image" content="http://lyyua.com/2018/04/12/cpp_memory/singleinherit.jpg">
<meta property="og:image" content="http://lyyua.com/2018/04/12/cpp_memory/multieinherit.jpg">
<meta property="og:image" content="http://lyyua.com/2018/04/12/cpp_memory/multieinherit.png">
<meta property="og:image" content="http://lyyua.com/2018/04/12/cpp_memory/multieinherit1.png">
<meta property="og:image" content="http://lyyua.com/2018/04/12/cpp_memory/virtualinherit.jpg">
<meta property="og:image" content="http://lyyua.com/2018/04/12/cpp_memory/h_virtualinherit.jpg">
<meta property="og:image" content="http://lyyua.com/2018/04/12/cpp_memory/i_virtualinherit.jpg">
<meta property="og:image" content="http://lyyua.com/2018/04/12/cpp_memory/functionvirtual.jpg">
<meta property="og:image" content="http://lyyua.com/2018/04/12/cpp_memory/R.jpg">
<meta property="og:image" content="http://lyyua.com/2018/04/12/cpp_memory/S.jpg">
<meta property="og:image" content="http://lyyua.com/2018/04/12/cpp_memory/multievirtualinherit.png">
<meta property="og:updated_time" content="2018-04-13T08:21:24.644Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++ 对象模型">
<meta name="twitter:description" content="先交代最基本的原则。">
<meta name="twitter:image" content="http://lyyua.com/2018/04/12/cpp_memory/struct1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://lyyua.com/2018/04/12/cpp_memory/"/>





  <title>C++ 对象模型 | Back</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?d4860eb791209892b971cbc05d6eb81a";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->










</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Back</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description"></h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://lyyua.com/2018/04/12/cpp_memory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lyu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Back">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">C++ 对象模型</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-12T22:35:59+08:00">
                2018-04-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2018/04/12/cpp_memory/" class="leancloud_visitors" data-flag-title="C++ 对象模型">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>先交代最基本的原则。<a id="more"></a></p>
<h1 id="程序的内存分配："><a href="#程序的内存分配：" class="headerlink" title="程序的内存分配："></a>程序的内存分配：</h1><p>一个由C/C++编译的程序占用的内存分为以下几个部分：<br>1、栈区（stack）—  由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。<br>2、堆区（heap） —  一般由程序员分配释放，若程序员不释放，程序结束时可能由OS（操作系统）回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。<br>3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。<br>4、文字常量区  —常量字符串就是放在这里的。程序结束后由系统释放。<br>5、程序代码区—存放函数体的二进制代码。 </p>
<h1 id="对齐和包裹"><a href="#对齐和包裹" class="headerlink" title="对齐和包裹"></a>对齐和包裹</h1><p>简单的内存布局原则：成员变量按其被声明的顺序排列，按具体实现所规定的对齐原则在内存地址上对齐。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">struct InefficientPacking&#123;</div><div class="line">	U32 mU1; //32                         </div><div class="line">	F32 mF2; //32 </div><div class="line">	U8 mB3; //8</div><div class="line">	I32 mI4; //32</div><div class="line">	bool mB5; //8</div><div class="line">	char* mP6; //32       </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/2018/04/12/cpp_memory/struct1.png" alt=""></p>
<p>此时结构的大小是24字节。</p>
<p>混合数据成员大小，导致低效的struct包裹。</p>
<p>为什么会留下空隙？事实上每种数据类型有其天然的对齐方式，供CPU高效的从内存读/写，对齐是指，其内存地址是否为对齐字节大小的倍数(通常是2的幂)。</p>
<p>对齐是重要的，现在许多处理器实际上只能正常的读/写已对齐的数据块，例如，程序要求从0x6A341174地址读取32位整数，内存控制器便可愉快的载入数据，因为该地址是4字节对齐的。<br>如果要从0x6A341173载入32位整数，内存控制器需要读入两个4字节块，一块是0x6A341170，一块是0x6A341174。之后通过掩码和移位操作取得32位整数的两部分，再用逻辑OR操作把两部分合并。</p>
<p>一些微处理器甚至不做这些处理。若读/写非对齐数据，读出来或者写进去的可能只是随机数，甚至可能程序直接崩溃（比如PS2）。</p>
<p>作为一个良好的经验法则，数据类型应该需要其字节大小对齐，比如32位值通常需要4字节对齐，16位值通常需要2字节对齐，8位值通常可以存于任何地址（1字节对齐）。</p>
<p>在支持SIMD矢量数学的CPU中，每个SIMD寄存器含32个4字节浮点数，共128位（16字节），即16字节对齐。</p>
<p>所以，对于上述的InefficientPacking结构，可以进行重新排列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">struct InefficientPacking&#123;</div><div class="line">	U32 mU1; //32 （4字节对齐）                         </div><div class="line">	F32 mF2; //32 （4字节对齐）</div><div class="line">	char* mP6; //32	（4字节对齐）</div><div class="line">	I32 mI4; //32（4字节对齐）</div><div class="line">	bool mB5; //8 （1字节对齐）</div><div class="line">	U8 mB3; //8  （1字节对齐）</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/2018/04/12/cpp_memory/struct2.png" alt=""></p>
<p>此时总大小为20字节大小，并不是18，因为末端有2个字节的填充。</p>
<p>可以在结构末端填充两个字节，使整个结构的浪费的空间更为清晰。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">struct InefficientPacking&#123;</div><div class="line">	U32 mU1; //32 （4字节对齐）                         </div><div class="line">	F32 mF2; //32 （4字节对齐）</div><div class="line">	char* mP6; //32	（4字节对齐）</div><div class="line">	I32 mI4; //32（4字节对齐）</div><div class="line">	bool mB5; //8 （1字节对齐）</div><div class="line">	U8 mB3; //8  （1字节对齐）</div><div class="line">	U8 _pad[2] ; // 明确的填充</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还有一点，关于大小，抛开虚函数和虚继承，C++类实例的大小完全取决于一个类及其基类的成员变量！成员函数基本上不影响类实例的大小。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">struct  B &#123;  </div><div class="line">public :  </div><div class="line">   int  bm1;  </div><div class="line">protected :  </div><div class="line">   int  bm2;  </div><div class="line">private :  </div><div class="line">   int  bm3;  </div><div class="line">   static   int  bsm; //存在静态区  </div><div class="line">   void  bf();  </div><div class="line">   static   void  bsf();  </div><div class="line">   typedef   void * bpv;  </div><div class="line">   struct  N &#123; &#125;;  </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><img src="/2018/04/12/cpp_memory/cppstruct.jpg" alt=""></p>
<h1 id="在单继承上的分布"><a href="#在单继承上的分布" class="headerlink" title="在单继承上的分布"></a>在单继承上的分布</h1><p>基类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">struct  C &#123;  </div><div class="line">   int  c1;  </div><div class="line">   void  cf();  </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>派生类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">struct  D : C &#123;  </div><div class="line">   int  d1;  </div><div class="line">   void  df();  </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><img src="/2018/04/12/cpp_memory/singleinherit.jpg" alt=""></p>
<p>或者这么看<br>在VS类-&gt;属性-&gt;C/C++ –&gt; 命令行–&gt; 其他选项</p>
<blockquote>
<ul>
<li>/d1 reportAllClassLayout 查看所有类</li>
<li>/d1 reportSingleClassLayoutXXX（XXX为类名）</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class D	size(8):</div><div class="line">	+---</div><div class="line"> 0	| +--- (base class C)</div><div class="line"> 0	| | c1</div><div class="line">	| +---</div><div class="line"> 4	| d1</div><div class="line">	+---</div></pre></td></tr></table></figure>
<p>派生类要保留基类的所有属性和行为，自然地，每个派生类的实例都包含了一份完整的基类实例数据。<br>几乎所有C++厂商默认在单继承类层次下，每一个新的派生类都简单地把自己的成员变量添加到基类的成员变量之后，这样只要有了派生类D的指针，不需要去计算偏移量了。</p>
<p>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">D* pd;  </div><div class="line">pd-&gt;c1; // *(pd + dDC + dCc1); // *(pd + dCc1);   </div><div class="line">pd-&gt;d1; // *(pd + dDd1);</div></pre></td></tr></table></figure></p>
<blockquote>
<ul>
<li>当访问基类成员c1时，计算步骤本来应该为“pd+dDC+dCc1”，即为先计算D对象和C对象之间的偏移，C对象指针与成员变量c1之间的偏移量。由于dDC恒定为0，所以直接表达为pd+dCc1。</li>
<li>当访问派生类成员d1时，直接计算偏移量。</li>
</ul>
</blockquote>
<h1 id="多重继承上的分布"><a href="#多重继承上的分布" class="headerlink" title="多重继承上的分布"></a>多重继承上的分布</h1><p>定义一个结构E<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct E</div><div class="line">&#123;</div><div class="line">	int e1 = 5;</div><div class="line">	void ee();</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>再定义一个结构F，让他继承C、E<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct F :C, E</div><div class="line">&#123;</div><div class="line">	int f1 = 6;</div><div class="line">	void ff();</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><img src="/2018/04/12/cpp_memory/multieinherit.jpg" alt=""></p>
<p>此时看一下内存布局<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class F	size(12):</div><div class="line">	+---</div><div class="line"> 0	| +--- (base class C)</div><div class="line"> 0	| | c1</div><div class="line">	| +---</div><div class="line"> 4	| +--- (base class E)</div><div class="line"> 4	| | e1</div><div class="line">	| +---</div><div class="line"> 8	| f1</div><div class="line">	+---</div></pre></td></tr></table></figure></p>
<p>多继承的成员变量地址计算：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">F* pf;  </div><div class="line">pf-&gt;c1; // *(pf + dFC + dCc1); // *(pf + dFc1);   </div><div class="line">pf-&gt;e1; // *(pf + dFE + dEe1); // *(pf + dFe1);   </div><div class="line">pf-&gt;f1; // *(pf + dFf1);</div></pre></td></tr></table></figure></p>
<p>与单继承相同的是，F实例拷贝了每个基类的所有数据。 与单继承不同的是，在多重继承下，内嵌的两个基类C,E，他们的对象指针不可能全都与派生类对象指针相同：</p>
<p>输出一看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	F f;</div><div class="line">	std::stringstream ss;</div><div class="line">	ss &lt;&lt; &quot;F实例地址：&quot; &lt;&lt; &amp;f &lt;&lt; &quot;\n&quot;    //0073FBB4</div><div class="line">		&lt;&lt; &quot;转到基类C：&quot; &lt;&lt; (void*)(C*)&amp;f &lt;&lt; &quot;\n&quot;  //0073FBB4</div><div class="line">		&lt;&lt; &quot;转到基类E：&quot; &lt;&lt; (void*)(E*)&amp;f; //0073FBB8</div><div class="line">	std::cout &lt;&lt; ss.str() &lt;&lt; std::endl;</div><div class="line">	system(&quot;pause&quot;);</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>具体的编译器实现可以自由地选择内嵌基类和派生类的布局。 VC++ 按照基类的声明顺序 先排列基类实例数据，最后才排列派生类数据。 当然，派生类数据本身也是按照声明顺序布局的（本规则并非一成不变 ，我们会看到，当一些基类有虚函数而另一些基类没有时，内存布局并非如此）。</p>
<h1 id="虚继承上的分布"><a href="#虚继承上的分布" class="headerlink" title="虚继承上的分布"></a>虚继承上的分布</h1><h2 id="虚继承的作用："><a href="#虚继承的作用：" class="headerlink" title="虚继承的作用："></a>虚继承的作用：</h2><p>如果经理类和工人类都继承自“雇员类”，将会发生什么？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">struct  Employee &#123; ... &#125;;  </div><div class="line">struct  Manager : Employee &#123; ... &#125;;  </div><div class="line">struct  Worker : Employee &#123; ... &#125;;  </div><div class="line">struct  MiddleManager : Manager, Worker &#123; ... &#125;;</div></pre></td></tr></table></figure>
<p>如果经理类和工人类都继承自雇员类，很自然地，它们每个类都会从雇员类获得一份数据拷贝。</p>
<blockquote>
<ul>
<li>成员变量名的二义性，Manager继承至Employee，有工资属性，Worker继承至Employee，也有工资属性，那么MiddleManager实例的工资属性指向的是哪个？</li>
<li>两个实例，如果不作特殊处理，一线经理类的实例将含有<strong>两个雇员类实例</strong>，它们分别来自两个雇员基类 。</li>
<li>空间浪费，如果雇员类成员变量不多，问题不严重；如果成员变量众多，则那份多余的拷贝将造成实例生成时的严重开销。</li>
<li>数据不安全，这两份不同的雇员实例可能分别被修改，比如一线经理类强转成Worker类，此时修改的工资属性，造成数据的不一致。</li>
</ul>
</blockquote>
<p>可以打开VS写个示例看看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">struct C&#123; int c1 =0;&#125;</div><div class="line">struct D : C&#123;...&#125;</div><div class="line">struct DD : C&#123;...&#125;</div><div class="line">struct FF : D,DD&#123;...&#125;</div><div class="line">int main()&#123;</div><div class="line">	FF ff;</div><div class="line">	DD* dd = (DD*)&amp;ff;</div><div class="line">	dd-&gt;c1 = 999;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出：<br><img src="/2018/04/12/cpp_memory/multieinherit.png" alt=""></p>
<p>依然是上面的实例，稍微改一改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">struct C&#123; int c1 =0;&#125;</div><div class="line">struct D : virtual C&#123;...&#125;</div><div class="line">struct DD : virtual C&#123;...&#125;</div><div class="line">struct FF : D,DD&#123;...&#125;</div><div class="line">int main()&#123;</div><div class="line">	FF ff;</div><div class="line">	DD* dd = (DD*)&amp;ff;</div><div class="line">	dd-&gt;c1 = 999;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="/2018/04/12/cpp_memory/multieinherit1.png" alt=""></p>
<p>这样，操作的其实就是同一份内存了。</p>
<h2 id="虚继承的内存分布："><a href="#虚继承的内存分布：" class="headerlink" title="虚继承的内存分布："></a>虚继承的内存分布：</h2><p>在单继承和多重继承的情况下，内嵌的基类实例地址比起派生类实例地址来，要么地址相同（单继承，以及多重继承的最靠左基类） ，要么地址相差一个固定偏移量（多重继承的非最靠左基类） 。 </p>
<p>然而，当虚继承时，一般说来，派生类地址和其虚基类地址之间的偏移量是不固定的，因为如果这个派生类又被进一步继承的话，最终派生类会把共享的虚基类实例数据放到一个与上一层派生类不同的偏移量处。</p>
<p>定义G虚继承于C<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct G :virtual C</div><div class="line">&#123;</div><div class="line">	int g1 =9;</div><div class="line">	void gg();</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><img src="/2018/04/12/cpp_memory/virtualinherit.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class G	size(12):</div><div class="line">	+---</div><div class="line"> 0	| &#123;vbptr&#125;</div><div class="line"> 4	| g1</div><div class="line">	+---</div><div class="line">	+--- (virtual base C)</div><div class="line"> 8	| c1</div><div class="line">	+---</div><div class="line">G::$vbtable@:</div><div class="line"> 0	| 0</div><div class="line"> 1	| 8 (Gd(G+0)C)</div></pre></td></tr></table></figure>
<p>GdGvbptrG 是指在G对象中，G对象指针与G虚基类表的指针偏移量，自然为0；<br>GdGvbptrC 是指在G对象中，G对象指针与C虚基类表的指针偏移量，为8</p>
<p>同理，如果让H虚继承于C，也会得到类似的结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">struct H : virtual C&#123;</div><div class="line">	int h1 = 10;</div><div class="line">	void hh();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="/2018/04/12/cpp_memory/h_virtualinherit.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class H	size(12):</div><div class="line">	+---</div><div class="line"> 0	| &#123;vbptr&#125;</div><div class="line"> 4	| h1</div><div class="line">	+---</div><div class="line">	+--- (virtual base C)</div><div class="line"> 8	| c1</div><div class="line">	+---</div><div class="line">H::$vbtable@:</div><div class="line"> 0	| 0</div><div class="line"> 1	| 8 (Hd(H+0)C)</div></pre></td></tr></table></figure></p>
<p>此时再定义一个I<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">struct  I : G, H &#123;  </div><div class="line">   int  i1;  </div><div class="line">   void  _if();  </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><img src="/2018/04/12/cpp_memory/i_virtualinherit.jpg" alt=""></p>
<p>或者直接看你下面的内存布局</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">class I	size(24):</div><div class="line">	+---</div><div class="line"> 0	| +--- (base class G)</div><div class="line"> 0	| | &#123;vbptr&#125;</div><div class="line"> 4	| | g1</div><div class="line">	| +---</div><div class="line"> 8	| +--- (base class H)</div><div class="line"> 8	| | &#123;vbptr&#125;</div><div class="line">12	| | h1</div><div class="line">	| +---</div><div class="line">16	| i1</div><div class="line">	+---</div><div class="line">	+--- (virtual base C)</div><div class="line">20	| c1</div><div class="line">	+---</div><div class="line"></div><div class="line">I::$vbtable@G@:</div><div class="line"> 0	| 0  </div><div class="line"> 1	| 20 (Id(G+0)C)    //G ~ I 为0  G ~ C 为20</div><div class="line"></div><div class="line">I::$vbtable@H@:</div><div class="line"> 0	| 0</div><div class="line"> 1	| 12 (Id(H+0)C)   //H ~ H 为0  H ~ C 为12</div></pre></td></tr></table></figure>
<p>看内存布局图，就很容易计算虚继承中成员变量的地址：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">I* pi;   //I实例地址</div><div class="line">pi-&gt;c1; // *(pi + (I~G) + (G~C) + dCc1);   </div><div class="line">pi-&gt;g1; // *(pi + dIG + dGg1); // *(pi + dIg1);   </div><div class="line">pi-&gt;h1; // *(pi + dIH + dHh1); // *(pi + dIh1);   </div><div class="line">pi-&gt;i1; // *(pi + dIi1);   </div><div class="line">I i;  </div><div class="line">i.c1; // *(&amp;i + IdIC + dCc1); // *(&amp;i + IdIc1); //当声明了一个对象实例，用点“.”操作符访问虚基类成员c1时，由于编译时就完全知道对象的布局情况，所以可以直接计算偏移量。</div></pre></td></tr></table></figure></p>
<p>从上述例子中可以发现：</p>
<blockquote>
<ul>
<li>在VC++ 中，对每个继承自虚基类的类实例，将增加一个隐藏的<strong>“虚基类表指针”（vbptr）</strong> 成员变量，从而达到间接计算虚基类位置的目的。该变量指向一个全类共享的偏移量表，表中项目记录了对于该类而言，“虚基类表指针”与虚基类之间的偏移量。</li>
</ul>
</blockquote>
<p>总结下继承和虚继承：</p>
<blockquote>
<ul>
<li>1、首先排列非虚继承的基类实例；</li>
<li>2、有虚基类时，为每个虚基类增加一个隐藏的vbptr，除非已经从非虚继承的类那里继承了一个vbptr；</li>
<li>3、排列派生类的新数据成员；</li>
<li>4、在实例最后，排列每个虚基类的一个实例。</li>
</ul>
</blockquote>
<p>该布局安排使得虚基类的位置随着派生类的不同而“浮动不定”，但是，非虚基类因此也就凑在一起，彼此的偏移量固定不变。</p>
<h1 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h1><h2 id="非虚继承"><a href="#非虚继承" class="headerlink" title="非虚继承"></a>非虚继承</h2><p>如果没有虚基类的问题，将一个指针强制转化为另一个类型的指针代价并不高昂。如果在要求转化的两个指针之间有“基类-派生类”关系，编译器只需要简单地在两者之间加上或者减去一个偏移量即可（并且该量还往往为0）。</p>
<p>用上面定义的几个类说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">F* pf;  </div><div class="line">(C*)pf; // (C*)(pf ? pf + dFC : 0); // (C*)pf;   </div><div class="line">(E*)pf; // (E*)(pf ? pf + dFE : 0);</div></pre></td></tr></table></figure></p>
<h2 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h2><p>当继承关系中存在虚基类时，强制转化的开销会比较大。具体说来，和访问虚基类成员变量的开销相当。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">I* pi;  </div><div class="line">(G*)pi; // (G*)pi;   </div><div class="line">(H*)pi; // (H*)(pi ? pi + dIH : 0);   </div><div class="line">(C*)pi; // (C*)(pi ? (pi+dIGvbptr + (*(pi+dIGvbptr))[1]) : 0);  //dIGvbptr[1] 虚基类表的第二个，这里是指在I实例中，G到C的偏移量</div></pre></td></tr></table></figure>
<p>一般说来，当从派生类中访问虚基类成员时，应该先强制转化派生类指针为虚基类指针，然后一直使用虚基类指针来访问虚基类成员变量。这样做，可以避免每次都要计算虚基类地址的开销。 见下例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/* before: */             … pi-&gt;c1 … pi-&gt;c1 …</div><div class="line">/* faster: */ C* pc = pi; … pc-&gt;c1 … pc-&gt;c1 …  //先抓出来</div></pre></td></tr></table></figure></p>
<h1 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h1><p>如代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct  P &#123;  </div><div class="line">   int  p1;  </div><div class="line">   void  pf();  // new   </div><div class="line">   virtual   void  pvf();  // new   </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>P有一个非虚成员函数pf()，以及一个虚成员函数pvf()。</p>
<p>很明显，虚成员 函数造成对象实例占用更多内存空间，因为虚成员函数需要虚函数表指针。这里要特别指出的是,声明<strong>非虚成员函数</strong>不会造成任何对象实例的内存开销。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void  P::pf() &#123;  // void P::pf([P *const this])   </div><div class="line">   ++p1;   // ++(this-&gt;p1); 隐式的调用了this   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意成员变量访问也许比看起来要代价高昂一些，因为成员变量访问通过this指针进行，<strong>在有的继承层次下，this指针需要调整</strong>，所以访问的开销可能会比较大。然而，<strong>从另一方面来说，编译器通常会把this指针缓存到寄存器中</strong>，所以，成员变量访问的代价不会比访问局部变量的效率更差。</p>
<h1 id="覆盖成员函数"><a href="#覆盖成员函数" class="headerlink" title="覆盖成员函数"></a>覆盖成员函数</h1><p>和成员变量一样，成员函数也会被继承。与成员变量不同的是，通过在派生类中重新定义基类函数，一个派生类可以覆盖，或者说替换掉基类的函数定义。<strong>覆盖是静态 （根据成员函数的静态类型在编译时决定）还是动态（通过对象指针在运行时动态决定），依赖于成员函数是否被声明为“虚函数”。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct  Q : P &#123;  </div><div class="line">   int  q1;  </div><div class="line">   void  pf();  // overrides P::pf   </div><div class="line">   void  qf();  // new   </div><div class="line">   void  pvf();  // overrides P::pvf  重写了P::pvf()  </div><div class="line">   virtual   void  qvf();  // new   </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><img src="/2018/04/12/cpp_memory/functionvirtual.jpg" alt=""></p>
<p>P::vfptr此时的对应的是虚函数表，指向的是Q::pvf Q::qvf 这两个虚函数</p>
<h2 id="非虚函数调用"><a href="#非虚函数调用" class="headerlink" title="非虚函数调用"></a>非虚函数调用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">P p; P* pp = &amp;p; Q q; P* ppq = &amp;q; Q* pq = &amp;q;  </div><div class="line">pp-&gt;pf(); // pp-&gt;P::pf(); // P::pf(pp);   </div><div class="line">ppq-&gt;pf(); // ppq-&gt;P::pf(); // P::pf(ppq);   不是调用的Q::pf()</div><div class="line">pq-&gt;pf(); // pq-&gt;Q::pf(); // Q::pf((Q*)pq); （错误!）   </div><div class="line">pq-&gt;qf(); // pq-&gt;Q::qf(); // Q::qf(pq);</div></pre></td></tr></table></figure>
<p>对于<strong>非虚</strong>的成员函数来说，调用哪个成员函数是在编译时，根据“-&gt;”操作符左边指针表达式的类型静态决定的<strong>（编译时就决定了的）</strong>。特别地，即使ppq指向Q的实例，ppq-&gt;pf()仍然调用的是P::pf()，因为ppq被声明为“P*”。（注意，“-&gt;”操作符左边的指针类型决定隐藏的this参数的类型。）</p>
<h2 id="虚函数的调用"><a href="#虚函数的调用" class="headerlink" title="虚函数的调用"></a>虚函数的调用</h2><p>对于虚函数 调用来说，调用哪个成员函数在<strong>运行时</strong>决定。不管“-&gt;”操作符左边的指针表达式的类型如何，调用的虚函数都是由指针实际指向的实例类型所决定 。比如，尽管ppq的类型是P*，当ppq指向Q的实例时，调用的仍然是Q::pvf()。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pp-&gt;pvf();  // pp-&gt;P::pvf(); // P::pvf(pp);   </div><div class="line">ppq-&gt;pvf(); // ppq-&gt;Q::pvf(); // Q::pvf((Q*)ppq);   </div><div class="line">pq-&gt;pvf(); // pq-&gt;Q::pvf(); // Q::pvf((P*)pq); （错误！）</div></pre></td></tr></table></figure>
<h2 id="为什么有虚函数表"><a href="#为什么有虚函数表" class="headerlink" title="为什么有虚函数表"></a>为什么有虚函数表</h2><p>为了实现这种动态的机制，引入了隐藏的vfptr 成员变量。 一个vfptr被加入到类中（如果类中没有的话），该vfptr指向<strong>类的虚函数表</strong>（vftable）。类中每个虚函数在该类的虚函数表中都占据一项。每项保存一个对于该类适用的虚函数的地址。因此，调用虚函数的过程如下：<strong>取得实例的vfptr，通过vfptr得到虚函数表的一项</strong>；通过虚函数表该项的函数地址间接调用虚函数。 也就是说，在普通函数调用的参数传递、调用、返回指令开销外，虚函数调用还需要<strong>额外的开销</strong>。</p>
<h2 id="多重继承的虚函数"><a href="#多重继承的虚函数" class="headerlink" title="多重继承的虚函数"></a>多重继承的虚函数</h2><p>VC++的实现方式是，保证任何有虚函数的类的第一项永远是vfptr。在多重继承时，虽然在右边，然而有vfptr的基类放到左边没有vfptr的基类的前面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct  R &#123;  </div><div class="line">   int  r1;  </div><div class="line">   virtual   void  pvf();  // new   </div><div class="line">   virtual   void  rvf();  // new   </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><img src="/2018/04/12/cpp_memory/R.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct  S : P, R &#123;  </div><div class="line">   int  s1;  </div><div class="line">   void  pvf();  // overrides P::pvf and R::pvf   </div><div class="line">   void  rvf();  // overrides R::rvf   </div><div class="line">   void  svf();  // new   </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><img src="/2018/04/12/cpp_memory/S.jpg" alt=""></p>
<p>从左至右，虚函数表排第一。</p>
<p><img src="/2018/04/12/cpp_memory/multievirtualinherit.png" alt=""></p>
<p>在多重继承下，靠右的基类R，其实例的地址和P与S不同。 S::pvf覆盖了P::pvf()和R::pvf()，S::rvf()覆盖了R::rvf()。</p>
<p>实际代码中对虚函数的调用过程如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">S s; S* ps = &amp;s;  </div><div class="line">((P*)ps)-&gt;pvf(); // (*(P*)ps)-&gt;P::vfptr[0])((S*)(P*)ps)   </div><div class="line">((R*)ps)-&gt;pvf(); // (*(R*)ps)-&gt;R::vfptr[0])((S*)(R*)ps)   </div><div class="line">ps-&gt;pvf();       // one of the above; calls S::pvf()</div></pre></td></tr></table></figure></p>
<p>1、因为S::pvf()覆盖了P::pvf()和R::pvf()，在S的虚函数 表中，相应的项也应该被覆盖。</p>
<p>2、但是，不光可以用P<em>，还可以用R</em>来调用pvf()。</p>
<p>3、问题出现了：R的地址与P和S的地址不同。表达式 (R<em>)ps与表达式(P</em>)ps指向类布局中不同的位置。</p>
<p>4、因为函数S::pvf希望获得一个S<em>作为隐藏的this指针参数，虚函数必须把R</em> 转化为 S*。</p>
<p>5、因此，在S对R虚函数表的拷贝中，pvf函数对应的项，指向的是一个<strong>调整块</strong>的地址，该调整块使用必要的计算，把R<em>转换为需要的S</em>。</p>
<blockquote>
<ul>
<li>这就是“thunk1: this-= sdPR; goto S::pvf”干的事。先根据P和R在S中的偏移，调整this为P<em>，也就是S</em>，然后跳转到相应的虚函数处执行。</li>
</ul>
</blockquote>
<h2 id="虚继承下的虚函数"><a href="#虚继承下的虚函数" class="headerlink" title="虚继承下的虚函数"></a>虚继承下的虚函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">struct  T :  virtual  P &#123;  </div><div class="line">   int  t1;  </div><div class="line">   void  pvf();          // overrides P::pvf   </div><div class="line">   virtual   void  tvf();  // new   </div><div class="line">&#125;;  </div><div class="line">void  T::pvf() &#123;  </div><div class="line">   ++p1; // ((P*)this)-&gt;p1++; // vbtable lookup!   </div><div class="line">   ++t1; // this-&gt;t1++;   </div><div class="line">&#125;</div><div class="line">``` </div><div class="line">![](cpp_memory/_virtualinheritfunction.jpg)</div><div class="line">![](cpp_memory/virtualinheritfunction.jpg)</div><div class="line"></div><div class="line">T虚继承P，覆盖P的虚成员函数，声明了新的虚函数。</div><div class="line"></div><div class="line">如果采用在基类虚函数表末尾添加新项的方式，则访问虚函数总要求访问虚基类。</div><div class="line"></div><div class="line">在VC++中，为了避免获取虚函数表时，转换到虚基类P的高昂代价，T中的新虚函数通过一个新的虚函数表获取 ，从而带来了一个新的虚函数表指针。该指针放在T实例的顶端。</div><div class="line"></div><div class="line">即使是在虚函数中，**访问虚基类的成员变量**也要通过获取虚基类表的偏移，实行计算来进行。这样做之所以必要，是因为**虚函数可能被进一步继承的类所覆盖**，而进一步继承的类的布局中，虚基类的位置变化了。比如：</div></pre></td></tr></table></figure>
<p>struct  U : T {<br>   int  u1;<br>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">![](cpp_memory/__virtualinheritfunction.jpg)</div><div class="line">![](cpp_memory/virtualinheritfunction1.jpg)</div><div class="line"></div><div class="line">在U增加了一个成员变量，从而改变了P的偏移。</div><div class="line"></div><div class="line">由于P是虚基类，T中有一个P，P自己也有一份，当然他们的地址是相同的。</div><div class="line"></div><div class="line">因为VC++实现中，T::pvf()接受的是嵌套在T中的P的指针，所以，需要提供一个调整块，把this指针调整到T::t1之后（该处即是P在T中的位置）。</div><div class="line"></div><div class="line">简单的说，就是存在通过强转导致的U::pvf()，T::pvf()这种情况，导致不知道具体调用那个函数，需要调整块。</div><div class="line"></div><div class="line"># 构造函数和析构函数</div><div class="line"></div><div class="line">最坏的情况下，构造函数：</div><div class="line">&gt;* 如果是“最终派生类”，初始化vbptr成员变量，调用虚基类的构造函数；</div><div class="line">&gt;* 调用非虚基类的构造函数</div><div class="line">&gt;* 调用成员变量的构造函数</div><div class="line">&gt;* 初始化虚函数表成员变量</div><div class="line">&gt;* 执行构造函数体中，程序所定义的其他初始化代码</div><div class="line"></div><div class="line">析构函数：</div><div class="line">&gt;* 合成并初始化虚函数表成员变量</div><div class="line">&gt;* 执行析构函数体中，程序定义的其他析构代码</div><div class="line">&gt;* 调用成员变量的析构函数（按照相反的顺序，沿子类到基类）</div><div class="line">&gt;* 调用直接非虚基类的析构函数（按照相反的顺序）</div><div class="line">&gt;* 如果是“最终派生类”，调用虚基类的析构函数（按照相反顺序）</div><div class="line"></div><div class="line"></div><div class="line"># 虚析构函数的作用</div><div class="line"></div><div class="line">假如A是B的父类，</div><div class="line"></div><div class="line">A* p = new B();</div><div class="line"></div><div class="line">如果析构函数不是虚拟的，那么，你后面就必须这样才能安全的删除这个指针：</div><div class="line"></div><div class="line">delete (B*)p;</div><div class="line"></div><div class="line">但如果析构函数是虚拟的，就可以在运行时动态绑定到B类的析构函数，直接：</div><div class="line"></div><div class="line">delete p;</div><div class="line"></div><div class="line">就可以了。这就是虚析构函数的作用。</div><div class="line"></div><div class="line">虚析构函数和普通的虚函数内存分布机制相同。</div><div class="line"></div><div class="line">虚析构函数的特别之处在于：当类实例被销毁时，虚析构函数被隐含地调用。调用地（delete发生的地方）虽然不知道销毁的**动态类型**，然而，要保证调用对该类型合适的delete操作符。</div></pre></td></tr></table></figure></p>
<p>struct  V {<br>   virtual  ~V();<br>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>struct  W : V {<br>   operator delete ();<br>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>V* pv =  new  V;<br>delete  pv;    // pv-&gt;~V::V(); // use ::operator delete()  V没有定义delete操作符，使用函数库的delete<br>pv = new  W;<br>delete  pv;    // pv-&gt;~W::W(); // use W::operator delete() 动态绑定到 W的析构函数，W默认的析构函数调用{delete this;}  指向的是W实例，调用的也是W的delete<br>pv = new  W;<br>::delete  pv;  // pv-&gt;~W::W(); // use ::operator delete()  使用全局范围标识符，显示调用函数库delete<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"># 数组</div><div class="line"></div><div class="line">堆上分配空间的数组使虚析构函数进一步复杂化。问题变复杂的原因有两个：</div><div class="line"></div><div class="line">&gt;* 堆上分配空间的数组，由于数组可大可小，所以，数组大小值应该和数组一起保存。因此，堆上分配空间的数组会分配额外的空间来存储数组元素的个数；</div><div class="line"></div><div class="line">&gt;* 当数组被删除时，数组中每个元素都要被正确地释放，即使当数组大小不确定时也必须成功完成该操作。然而，派生类可能比基类占用更多的内存空间，从而使正确释放比较困难。</div></pre></td></tr></table></figure></p>
<p>struct  WW : W {  int  w1; };<br>pv = new  W[m];<br>delete  [] pv;  // delete m W’s (sizeof(W) == sizeof(V))<br>pv = new  WW[n];<br>delete  [] pv;  // delete n WW’s (sizeof(WW) &gt; sizeof(V))<br>```</p>
<p>WW从W继承，增加了一个成员变量，因此，WW占用的内存空间比W大。然而，不管指针pv指向W的数组还是WW的数组，delete[]都必须正确地释放WW或W对象占用的内存空间。</p>
<p>在MSC++中，delete[]是用另一个编译器生成的虚析构帮助函数来完成。该函数被称为“向量delete析构函数”（因其针对特定的类定制，比如WW，所以，它能够遍历数组的每个元素，调用对<strong>每个元素适用的析构函数</strong>）。</p>
<p>参考：<br><a href="http://blog.jobbole.com/108457/" target="_blank" rel="external">http://blog.jobbole.com/108457/</a><br><a href="http://lib.csdn.net/article/cplusplus/63247" target="_blank" rel="external">http://lib.csdn.net/article/cplusplus/63247</a></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/04/10/cpp_Template/" rel="next" title="C++ 模板">
                <i class="fa fa-chevron-left"></i> C++ 模板
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="lv-container" data-id="city" data-uid="MTAyMC8yOTgyMy82Mzg5"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="Lyu" />
          <p class="site-author-name" itemprop="name">Lyu</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">38</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#程序的内存分配："><span class="nav-number">1.</span> <span class="nav-text">程序的内存分配：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#对齐和包裹"><span class="nav-number">2.</span> <span class="nav-text">对齐和包裹</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#在单继承上的分布"><span class="nav-number">3.</span> <span class="nav-text">在单继承上的分布</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#多重继承上的分布"><span class="nav-number">4.</span> <span class="nav-text">多重继承上的分布</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#虚继承上的分布"><span class="nav-number">5.</span> <span class="nav-text">虚继承上的分布</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#虚继承的作用："><span class="nav-number">5.1.</span> <span class="nav-text">虚继承的作用：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#虚继承的内存分布："><span class="nav-number">5.2.</span> <span class="nav-text">虚继承的内存分布：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#强制转换"><span class="nav-number">6.</span> <span class="nav-text">强制转换</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#非虚继承"><span class="nav-number">6.1.</span> <span class="nav-text">非虚继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#虚继承"><span class="nav-number">6.2.</span> <span class="nav-text">虚继承</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#成员函数"><span class="nav-number">7.</span> <span class="nav-text">成员函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#覆盖成员函数"><span class="nav-number">8.</span> <span class="nav-text">覆盖成员函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#非虚函数调用"><span class="nav-number">8.1.</span> <span class="nav-text">非虚函数调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#虚函数的调用"><span class="nav-number">8.2.</span> <span class="nav-text">虚函数的调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么有虚函数表"><span class="nav-number">8.3.</span> <span class="nav-text">为什么有虚函数表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多重继承的虚函数"><span class="nav-number">8.4.</span> <span class="nav-text">多重继承的虚函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#虚继承下的虚函数"><span class="nav-number">8.5.</span> <span class="nav-text">虚继承下的虚函数</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lyu</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  






  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("9nfwurrfWspn4Ca1tpt8c4Bb-gzGzoHsz", "SmeoWp4XeDOxoGNiSegxpw2g");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
